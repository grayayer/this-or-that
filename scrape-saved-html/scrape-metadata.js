#!/usr/bin/env node

/**
 * Website Metadata Scraper
 * Scrapes detailed metadata from individual Land-book website pages
 * Uses the websites list generated by extract-websites.js
 */

const fs = require('fs');
const path = require('path');
const puppeteer = require('puppeteer');

class WebsiteMetadataScraper {
	constructor(options = {}) {
		this.browser = null;
		this.page = null;
		this.options = {
			headless: options.headless !== false,
			timeout: options.timeout || 30000,
			delay: options.delay || 2000, // Delay between requests
			maxConcurrent: options.maxConcurrent || 1, // Process one at a time
			downloadImages: options.downloadImages || false,
			...options
		};
		this.results = [];
		this.errors = [];
	}

	/**
	 * Initialize the browser
	 */
	async initialize() {
		console.log('üöÄ Initializing metadata scraper...');

		try {
			this.browser = await puppeteer.launch({
				headless: this.options.headless,
				args: [
					'--no-sandbox',
					'--disable-setuid-sandbox',
					'--disable-dev-shm-usage'
				]
			});

			this.page = await this.browser.newPage();
			await this.page.setUserAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
			await this.page.setViewport({ width: 1200, height: 800 });
			this.page.setDefaultTimeout(this.options.timeout);

			console.log('‚úÖ Browser initialized successfully');
			return true;
		} catch (error) {
			console.error('‚ùå Failed to initialize browser:', error.message);
			return false;
		}
	}

	/**
	 * Reinitialize browser if it's crashed or closed
	 */
	async reinitializeBrowser() {
		console.log('üîÑ Reinitializing browser...');

		try {
			if (this.browser) {
				await this.browser.close();
			}
		} catch (error) {
			// Ignore errors when closing crashed browser
		}

		return await this.initialize();
	}

	/**
	 * Scrape metadata from a single website
	 * @param {Object} website - Website data from the list
	 * @returns {Promise<Object>} - Scraped metadata
	 */
	async scrapeWebsiteMetadata(website) {
		console.log(`üîç Scraping: ${website.name}`);

		try {
			// Check if browser/page is still valid
			if (!this.page || this.page.isClosed()) {
				const reinitialized = await this.reinitializeBrowser();
				if (!reinitialized) {
					throw new Error('Failed to reinitialize browser');
				}
			}

			// Navigate to the website detail page
			await this.page.goto(website.postUrl, {
				waitUntil: 'networkidle2',
				timeout: this.options.timeout
			});

			// Wait a moment for content to load
			await new Promise(resolve => setTimeout(resolve, 2000));

			// Extract metadata using page.evaluate
			const metadata = await this.page.evaluate(() => {
				const result = {
					title: null,
					description: null,
					tags: {
						style: [],
						industry: [],
						typography: [],
						type: [],
						category: [],
						platform: [],
						colors: []
					},
					screenshotUrl: null,
					websiteUrl: null,
					author: null
				};

				// Extract title
				const titleElement = document.querySelector('h1, .website-title, [class*="title"]');
				if (titleElement) {
					result.title = titleElement.textContent.trim();
				}

				// Extract description
				const descElement = document.querySelector('.website-description, [class*="description"], .lead');
				if (descElement) {
					result.description = descElement.textContent.trim();
				}

				// Extract website URL
				const websiteLink = document.querySelector('a[href*="http"]:not([href*="land-book.com"])');
				if (websiteLink) {
					result.websiteUrl = websiteLink.href;
				}

				// Extract screenshot URL
				const screenshotImg = document.querySelector('img[src*="screenshot"], .website-screenshot img, .preview-image img');
				if (screenshotImg) {
					result.screenshotUrl = screenshotImg.src;
				}

				// Extract tags from Land-book's specific structure
				const metadataContainer = document.querySelector('div.website-content-sidebar .bg-secondary');

				if (metadataContainer) {
					const rows = metadataContainer.querySelectorAll('.row');

					rows.forEach(row => {
						const labelCol = row.querySelector('.col-4 p.text-muted');
						const valueCol = row.querySelector('.col-8');

						if (labelCol && valueCol) {
							const label = labelCol.textContent.trim().toLowerCase();
							const links = valueCol.querySelectorAll('a.text-decoration-underline');

							links.forEach(link => {
								const tagText = link.textContent.trim();
								if (tagText) {
									// Map Land-book labels to our tag categories
									switch (label) {
										case 'style':
											result.tags.style.push(tagText);
											break;
										case 'industry':
											result.tags.industry.push(tagText);
											break;
										case 'typography':
											result.tags.typography.push(tagText);
											break;
										case 'type':
											result.tags.type.push(tagText);
											break;
										case 'category':
											result.tags.category.push(tagText);
											break;
										default:
											// For any other categories, add to category
											result.tags.category.push(tagText);
											break;
									}
								}
							});
						}
					});
				}

				// Extract colors from Land-book's color palette
				const colorContainer = metadataContainer?.querySelector('.website-colors');
				if (colorContainer) {
					const colorElements = colorContainer.querySelectorAll('.website-colors-item');
					colorElements.forEach(colorEl => {
						const style = colorEl.style.backgroundColor;
						if (style) {
							result.tags.colors.push(style);
						}
					});
				}

				// Clean up empty arrays
				Object.keys(result.tags).forEach(key => {
					result.tags[key] = [...new Set(result.tags[key])]; // Remove duplicates
				});

				return result;
			});

			// Combine with original website data and add missing properties
			const combinedData = {
				...website,
				...metadata,
				source: "land-book",
				sourceUrl: website.postUrl, // This is the Land-book page URL
				scrapedAt: new Date().toISOString()
			};

			console.log(`   ‚úÖ Successfully scraped metadata`);
			console.log(`   üìä Tags found: ${Object.values(metadata.tags).flat().length}`);

			return {
				success: true,
				data: combinedData
			};

		} catch (error) {
			console.log(`   ‚ùå Failed to scrape: ${error.message}`);

			// If it's a browser/session error, try to reinitialize and retry once
			if (error.message.includes('Session closed') ||
				error.message.includes('detached Frame') ||
				error.message.includes('Protocol error')) {

				console.log(`   üîÑ Attempting to recover from browser error...`);
				const reinitialized = await this.reinitializeBrowser();

				if (reinitialized) {
					try {
						console.log(`   üîÑ Retrying: ${website.name}`);
						return await this.scrapeWebsiteMetadata(website);
					} catch (retryError) {
						console.log(`   ‚ùå Retry failed: ${retryError.message}`);
					}
				}
			}

			this.errors.push({
				website: website.name,
				url: website.postUrl,
				error: error.message
			});

			return {
				success: false,
				error: error.message,
				data: website // Return original data as fallback
			};
		}
	}

	/**
	 * Process a list of websites
	 * @param {Array} websites - Array of website objects
	 * @returns {Promise<Object>} - Processing results
	 */
	async processWebsites(websites) {
		console.log(`üï∑Ô∏è  Processing ${websites.length} websites...`);

		for (let i = 0; i < websites.length; i++) {
			const website = websites[i];
			console.log(`\nüìÑ Processing ${i + 1}/${websites.length}: ${website.name}`);

			// Restart browser every 50 items to prevent memory leaks and crashes
			if (i > 0 && i % 50 === 0) {
				console.log(`üîÑ Restarting browser after ${i} items to prevent memory issues...`);
				await this.reinitializeBrowser();
			}

			const result = await this.scrapeWebsiteMetadata(website);
			this.results.push(result.data);

			// Add delay between requests to be respectful
			if (i < websites.length - 1) {
				const delay = this.options.delay + Math.random() * 1000; // Add some randomness
				console.log(`   ‚è≥ Waiting ${Math.round(delay)}ms before next request...`);
				await new Promise(resolve => setTimeout(resolve, delay));
			}
		}

		console.log(`\n‚úÖ Processing completed!`);
		console.log(`   Successfully processed: ${this.results.length}/${websites.length}`);
		console.log(`   Errors: ${this.errors.length}`);

		return {
			success: true,
			results: this.results,
			errors: this.errors,
			totalProcessed: websites.length
		};
	}

	/**
	 * Save results to JSON file
	 * @param {string} outputPath - Path to save the results
	 */
	async saveResults(outputPath) {
		try {
			const outputData = {
				metadata: {
					scrapedAt: new Date().toISOString(),
					totalWebsites: this.results.length,
					source: 'metadata-scraping',
					errors: this.errors.length
				},
				designs: this.results.map((result, index) => ({
					id: result.id || `design_${index + 1}`,
					image: result.screenshotUrl || result.thumbnailImage,
					title: result.title || result.name,
					tags: result.tags || {
						style: [],
						industry: [],
						typography: [],
						type: [],
						category: [],
						platform: [],
						colors: []
					},
					websiteUrl: result.websiteUrl || null,
					source: result.source || "land-book",
					sourceUrl: result.sourceUrl || null
				})),
				errors: this.errors
			};

			fs.writeFileSync(outputPath, JSON.stringify(outputData, null, 2));
			console.log(`üíæ Results saved to: ${outputPath}`);

			return true;
		} catch (error) {
			console.error(`‚ùå Error saving results: ${error.message}`);
			return false;
		}
	}

	/**
	 * Close the browser
	 */
	async close() {
		if (this.browser) {
			await this.browser.close();
			console.log('üîÑ Browser closed');
		}
	}
}

/**
 * Main execution function
 */
async function main() {
	const args = process.argv.slice(2);

	if (args.length === 0) {
		console.log('Usage: node scrape-metadata.js <websites-list.json> [options]');
		console.log('Options:');
		console.log('  --headless false    Run browser in visible mode');
		console.log('  --max-items N       Limit to N websites');
		console.log('  --delay N           Delay between requests (ms)');
		console.log('  --output FILE       Output file name');
		console.log('');
		console.log('Example: node scrape-metadata.js websites-list.json --max-items 10 --output designs.json');
		process.exit(1);
	}

	const websitesFile = args[0];

	// Parse command line options
	const options = {};
	let outputFile = 'scraped-designs.json';
	let maxItems = null;

	for (let i = 1; i < args.length; i++) {
		if (args[i] === '--headless' && args[i + 1]) {
			options.headless = args[i + 1] === 'true';
			i++;
		} else if (args[i] === '--max-items' && args[i + 1]) {
			maxItems = parseInt(args[i + 1]);
			i++;
		} else if (args[i] === '--delay' && args[i + 1]) {
			options.delay = parseInt(args[i + 1]);
			i++;
		} else if (args[i] === '--output' && args[i + 1]) {
			outputFile = args[i + 1];
			i++;
		}
	}

	// Check if websites file exists
	if (!fs.existsSync(websitesFile)) {
		console.error(`‚ùå Websites file not found: ${websitesFile}`);
		process.exit(1);
	}

	console.log('üöÄ Website Metadata Scraper');
	console.log('='.repeat(50));

	// Load websites list
	let websitesData;
	try {
		websitesData = JSON.parse(fs.readFileSync(websitesFile, 'utf8'));
	} catch (error) {
		console.error(`‚ùå Error reading websites file: ${error.message}`);
		process.exit(1);
	}

	let websites = websitesData.websites || websitesData;

	// Limit items if specified
	if (maxItems && maxItems < websites.length) {
		websites = websites.slice(0, maxItems);
		console.log(`üìä Limited to ${maxItems} websites for testing`);
	}

	console.log(`üìä Found ${websites.length} websites to process`);

	// Initialize scraper
	const scraper = new WebsiteMetadataScraper(options);
	const initialized = await scraper.initialize();

	if (!initialized) {
		console.error('‚ùå Failed to initialize scraper');
		process.exit(1);
	}

	try {
		// Process websites
		const results = await scraper.processWebsites(websites);

		// Save results
		const saved = await scraper.saveResults(outputFile);

		if (saved) {
			console.log(`\n‚úÖ Scraping completed successfully!`);
			console.log(`üìÑ Results saved to: ${outputFile}`);
			console.log(`üìä Total designs: ${results.results.length}`);
			console.log(`‚ùå Errors: ${results.errors.length}`);
		}

	} catch (error) {
		console.error(`‚ùå Scraping failed: ${error.message}`);
	} finally {
		await scraper.close();
	}
}

// Run if called directly
if (require.main === module) {
	main().catch(error => {
		console.error('‚ùå Execution failed:', error);
		process.exit(1);
	});
}

module.exports = { WebsiteMetadataScraper };